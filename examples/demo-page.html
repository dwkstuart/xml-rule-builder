<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML Rules Builder Demo</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@mui/material@5.15.0/umd/material-ui.development.js"></script>
    <script src="https://unpkg.com/@emotion/react@11.11.1/dist/emotion-react.umd.min.js"></script>
    <script src="https://unpkg.com/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 300;
        }
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1rem;
        }
        .content {
            padding: 30px;
        }
        .demo-section {
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #fafafa;
        }
        .demo-section h2 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        .config-example {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
        }
        .xml-output {
            background: #2d3748;
            color: #e2e8f0;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        .error {
            background: #fed7d7;
            border: 1px solid #feb2b2;
            color: #c53030;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .success {
            background: #c6f6d5;
            border: 1px solid #9ae6b4;
            color: #22543d;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        .button:hover {
            background: #5a67d8;
        }
        .button.secondary {
            background: #718096;
        }
        .button.secondary:hover {
            background: #4a5568;
        }
        .button.danger {
            background: #e53e3e;
        }
        .button.danger:hover {
            background: #c53030;
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .tab.active {
            border-bottom-color: #667eea;
            color: #667eea;
            font-weight: 600;
        }
        .tab:hover {
            background: #f7fafc;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>XML Rules Builder</h1>
            <p>A TypeScript library for building and managing XML-based rule systems</p>
            <p style="font-size: 0.9rem; margin-top: 10px; opacity: 0.8;">
                ✨ Now with configurable input field types: string, number, date, currency, and double
            </p>
        </div>
        
        <div class="content">
            <div class="tabs">
                <div class="tab active" onclick="switchTab('default')">Default Types</div>
                <div class="tab" onclick="switchTab('custom')">Custom Types</div>
                <div class="tab" onclick="switchTab('file')">File Configuration</div>
                <div class="tab" onclick="switchTab('import')">XML Import</div>
            </div>

            <div id="default-tab" class="tab-content active">
                <div class="demo-section">
                    <h2>Default XML Types Demo</h2>
                    <p>This demo shows the XML Rules Builder with the default rule types including input field configurations. The types include: Age (number), Date of Birth (date), Email (string with validation), Postcode/Zipcode (string with format validation), Income/Salary (currency with symbols), Price (double), Gender/Relationship Status/Nationality (string with predefined options), and Disabilities (number).</p>
                    
                    <div class="button-group">
                        <button class="button" onclick="loadDefaultTypes()">Load Default Types</button>
                        <button class="button secondary" onclick="showDefaultConfig()">Show Default Config</button>
                    </div>

                    <div id="default-builder"></div>
                    <div id="default-output"></div>
                </div>
            </div>

            <div id="custom-tab" class="tab-content">
                <div class="demo-section">
                    <h2>Custom XML Types Demo</h2>
                    <p>This demo shows how to use custom rule types defined programmatically.</p>
                    
                    <div class="config-example">
const customTypes = [
  {
    label: 'GPA',
    value: 'gpa',
    comparators: [
      { label: 'Greater Than', value: 'greater_than' },
      { label: 'Less Than', value: 'less_than' },
      { label: 'Equals', value: 'equals' }
    ]
  },
  {
    label: 'Course Level',
    value: 'course_level',
    comparators: [
      { label: 'Equals', value: 'equals' },
      { label: 'Not Equals', value: 'not_equals' }
    ]
  }
];
                    </div>

                    <div class="button-group">
                        <button class="button" onclick="loadCustomTypes()">Load Custom Types</button>
                        <button class="button secondary" onclick="resetToDefault()">Reset to Default</button>
                    </div>

                    <div id="custom-builder"></div>
                    <div id="custom-output"></div>
                </div>
            </div>

            <div id="file-tab" class="tab-content">
                <div class="demo-section">
                    <h2>File Configuration Demo</h2>
                    <p>This demo shows how to load XML types from a configuration file.</p>
                    
                    <div class="config-example">
// custom-types-config.json
{
  "ruleTypes": [
    {
      "label": "Test Score",
      "value": "test_score",
      "comparators": [
        { "label": "Greater Than", "value": "greater_than" },
        { "label": "Less Than", "value": "less_than" }
      ]
    },
    {
      "label": "Department",
      "value": "department",
      "comparators": [
        { "label": "Equals", "value": "equals" },
        { "label": "Not Equals", "value": "not_equals" }
      ]
    }
  ]
}
                    </div>

                    <div class="button-group">
                        <button class="button" onclick="loadFromFile()">Load from File</button>
                        <button class="button secondary" onclick="showFileConfig()">Show File Config</button>
                    </div>

                    <div id="file-builder"></div>
                    <div id="file-output"></div>
                </div>
            </div>

            <div id="import-tab" class="tab-content">
                <div class="demo-section">
                    <h2>XML Import Demo</h2>
                    <p>This demo shows how to import existing XML and populate the rules builder for editing.</p>
                    
                    <div class="config-example">
// Example XML to import:
&lt;rules&gt;
  &lt;group logic="AND"&gt;
    &lt;age comparator="greater_than"&gt;25&lt;/age&gt;
    &lt;income comparator="less_than"&gt;50000&lt;/income&gt;
  &lt;/group&gt;
  &lt;group logic="OR"&gt;
    &lt;gender comparator="equals"&gt;female&lt;/gender&gt;
    &lt;nationality comparator="equals"&gt;UK&lt;/nationality&gt;
  &lt;/group&gt;
&lt;/rules&gt;
                    </div>

                    <div class="button-group">
                        <button class="button" onclick="loadSampleXml()">Load Sample XML</button>
                        <button class="button secondary" onclick="loadCustomXml()">Load Custom XML</button>
                        <button class="button" onclick="clearImport()">Clear</button>
                    </div>

                    <div id="import-builder"></div>
                    <div id="import-output"></div>
                </div>
            </div>
        </div>
    </div>

    <script type="text/babel">
        // Mock implementation of the XML Rules Builder library
        // In a real scenario, this would be imported from the actual library
        
        const { useState, useEffect } = React;
        const { Box, Button, Select, MenuItem, TextField, Typography, Paper, Stack, Alert } = MaterialUI;

        // Mock types and utilities
        const mockXmlTypes = [
            {
                label: 'Age',
                value: 'age',
                comparators: [
                    { label: 'Equals', value: 'equals' },
                    { label: 'Less Than', value: 'less_than' },
                    { label: 'Greater Than', value: 'greater_than' },
                    { label: 'Between', value: 'between' }
                ],
                inputField: {
                    type: 'number',
                    placeholder: 'Enter age',
                    min: 0,
                    max: 150,
                    step: 1,
                    validation: {
                        custom: (value) => {
                            if (!/^\d+$/.test(value)) return 'Age must be a whole number';
                            const age = parseInt(value, 10);
                            if (age < 0) return 'Age must be positive';
                            if (age > 150) return 'Age must be less than 150';
                            return '';
                        }
                    }
                }
            },
            {
                label: 'Date of Birth',
                value: 'dob',
                comparators: [
                    { label: 'Before', value: 'before' },
                    { label: 'After', value: 'after' },
                    { label: 'On', value: 'on' },
                    { label: 'Between', value: 'between' }
                ],
                inputField: {
                    type: 'date',
                    dateFormat: 'YYYY-MM-DD',
                    validation: {
                        custom: (value) => {
                            if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) return 'Date must be YYYY-MM-DD';
                            const d = new Date(value);
                            if (isNaN(d.getTime())) return 'Invalid date';
                            const today = new Date();
                            if (d > today) return 'Date cannot be in the future';
                            return '';
                        }
                    }
                }
            },
            {
                label: 'Email',
                value: 'email',
                comparators: [
                    { label: 'Equals', value: 'equals' },
                    { label: 'Contains', value: 'contains' },
                    { label: 'Ends With', value: 'ends_with' },
                    { label: 'Domain', value: 'domain' }
                ],
                inputField: {
                    type: 'string',
                    placeholder: 'Enter email address',
                    validation: {
                        pattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$',
                        custom: (value) => {
                            if (value && !/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(value)) {
                                return 'Please enter a valid email address';
                            }
                            return '';
                        }
                    }
                }
            },
            {
                label: 'Postcode',
                value: 'postcode',
                comparators: [
                    { label: 'Equals', value: 'equals' },
                    { label: 'Starts With', value: 'starts_with' },
                    { label: 'In Area', value: 'in_area' }
                ],
                inputField: {
                    type: 'string',
                    placeholder: 'Enter postcode',
                    validation: {
                        pattern: '^[A-Z]{1,2}[0-9][A-Z0-9]? ?[0-9][A-Z]{2}$',
                        custom: (value) => {
                            if (value && !/^[A-Z]{1,2}[0-9][A-Z0-9]? ?[0-9][A-Z]{2}$/i.test(value)) {
                                return 'Please enter a valid UK postcode';
                            }
                            return '';
                        }
                    }
                }
            },
            {
                label: 'Zipcode',
                value: 'zipcode',
                comparators: [
                    { label: 'Equals', value: 'equals' },
                    { label: 'Starts With', value: 'starts_with' },
                    { label: 'In Area', value: 'in_area' }
                ],
                inputField: {
                    type: 'string',
                    placeholder: 'Enter zipcode',
                    validation: {
                        pattern: '^\\d{5}(-\\d{4})?$',
                        custom: (value) => {
                            if (value && !/^\d{5}(-\d{4})?$/.test(value)) {
                                return 'Please enter a valid US zipcode';
                            }
                            return '';
                        }
                    }
                }
            },
            {
                label: 'Income',
                value: 'income',
                comparators: [
                    { label: 'Less Than', value: 'less_than' },
                    { label: 'Greater Than', value: 'greater_than' },
                    { label: 'Equals', value: 'equals' },
                    { label: 'Between', value: 'between' }
                ],
                inputField: {
                    type: 'currency',
                    placeholder: 'Enter income',
                    currency: '£',
                    min: 0,
                    step: 0.01,
                    validation: {
                        custom: (value) => {
                            if (!/^\d+(\.\d{1,2})?$/.test(value)) return 'Income must be a valid number';
                            const income = parseFloat(value);
                            if (income < 0) return 'Income must be positive';
                            if (income > 1000000) return 'Income seems too high';
                            return '';
                        }
                    }
                }
            },
            {
                label: 'Salary',
                value: 'salary',
                comparators: [
                    { label: 'Less Than', value: 'less_than' },
                    { label: 'Greater Than', value: 'greater_than' },
                    { label: 'Equals', value: 'equals' },
                    { label: 'Between', value: 'between' }
                ],
                inputField: {
                    type: 'currency',
                    placeholder: 'Enter salary',
                    currency: '$',
                    min: 0,
                    step: 0.01,
                    validation: {
                        custom: (value) => {
                            if (!/^\d+(\.\d{1,2})?$/.test(value)) return 'Salary must be a valid number';
                            const salary = parseFloat(value);
                            if (salary < 0) return 'Salary must be positive';
                            if (salary > 1000000) return 'Salary seems too high';
                            return '';
                        }
                    }
                }
            },
            {
                label: 'Price',
                value: 'price',
                comparators: [
                    { label: 'Less Than', value: 'less_than' },
                    { label: 'Greater Than', value: 'greater_than' },
                    { label: 'Equals', value: 'equals' },
                    { label: 'Between', value: 'between' }
                ],
                inputField: {
                    type: 'double',
                    placeholder: 'Enter price',
                    min: 0,
                    step: 0.01,
                    validation: {
                        custom: (value) => {
                            if (!/^\d+(\.\d{1,2})?$/.test(value)) return 'Price must be a valid number';
                            const price = parseFloat(value);
                            if (price < 0) return 'Price must be positive';
                            return '';
                        }
                    }
                }
            },
            {
                label: 'Gender',
                value: 'gender',
                comparators: [
                    { label: 'Equals', value: 'equals' },
                    { label: 'Not Equals', value: 'not_equals' },
                    { label: 'In', value: 'in' }
                ],
                inputField: {
                    type: 'string',
                    placeholder: 'Enter gender',
                    validation: {
                        custom: (value) => {
                            const validGenders = ['male', 'female', 'other', 'prefer not to say'];
                            if (value && !validGenders.includes(value.toLowerCase())) {
                                return 'Please enter a valid gender (male, female, other, prefer not to say)';
                            }
                            return '';
                        }
                    }
                }
            },
            {
                label: 'Relationship Status',
                value: 'relationship_status',
                comparators: [
                    { label: 'Equals', value: 'equals' },
                    { label: 'Not Equals', value: 'not_equals' },
                    { label: 'In', value: 'in' }
                ],
                inputField: {
                    type: 'string',
                    placeholder: 'Enter relationship status',
                    validation: {
                        custom: (value) => {
                            const validStatuses = ['single', 'married', 'divorced', 'widowed', 'separated'];
                            if (value && !validStatuses.includes(value.toLowerCase())) {
                                return 'Please enter a valid status (single, married, divorced, widowed, separated)';
                            }
                            return '';
                        }
                    }
                }
            },
            {
                label: 'Nationality',
                value: 'nationality',
                comparators: [
                    { label: 'Equals', value: 'equals' },
                    { label: 'Not Equals', value: 'not_equals' },
                    { label: 'In', value: 'in' }
                ],
                inputField: {
                    type: 'string',
                    placeholder: 'Enter nationality',
                    validation: {
                        minLength: 2,
                        maxLength: 50,
                        custom: (value) => {
                            if (value && !/^[a-zA-Z\s]+$/.test(value)) {
                                return 'Nationality should only contain letters and spaces';
                            }
                            return '';
                        }
                    }
                }
            },
            {
                label: 'Disabilities',
                value: 'disabilities',
                comparators: [
                    { label: 'Has', value: 'has' },
                    { label: 'Does Not Have', value: 'does_not_have' },
                    { label: 'Count', value: 'count' }
                ],
                inputField: {
                    type: 'number',
                    placeholder: 'Enter number of disabilities',
                    min: 0,
                    max: 10,
                    step: 1,
                    validation: {
                        custom: (value) => {
                            if (!/^\d+$/.test(value)) return 'Must be a whole number';
                            const count = parseInt(value, 10);
                            if (count < 0) return 'Count must be positive';
                            if (count > 10) return 'Count must be 10 or less';
                            return '';
                        }
                    }
                }
            }
        ];

        const customTypes = [
            {
                label: 'GPA',
                value: 'gpa',
                comparators: [
                    { label: 'Greater Than', value: 'greater_than' },
                    { label: 'Less Than', value: 'less_than' },
                    { label: 'Equals', value: 'equals' }
                ]
            },
            {
                label: 'Course Level',
                value: 'course_level',
                comparators: [
                    { label: 'Equals', value: 'equals' },
                    { label: 'Not Equals', value: 'not_equals' }
                ]
            }
        ];

        const fileTypes = [
            {
                label: 'Test Score',
                value: 'test_score',
                comparators: [
                    { label: 'Greater Than', value: 'greater_than' },
                    { label: 'Less Than', value: 'less_than' }
                ]
            },
            {
                label: 'Department',
                value: 'department',
                comparators: [
                    { label: 'Equals', value: 'equals' },
                    { label: 'Not Equals', value: 'not_equals' }
                ]
            }
        ];

        // Sample XML for import demo
        const sampleXml = `<rules>
  <group logic="AND">
    <age comparator="greater_than">25</age>
    <income comparator="less_than">50000</income>
  </group>
  <group logic="OR">
    <gender comparator="equals">female</gender>
    <nationality comparator="equals">UK</nationality>
  </group>
</rules>`;

        // Function to parse XML and convert to rule blocks
        function parseXmlToRules(xmlString, availableTypes) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
                
                if (xmlDoc.getElementsByTagName('parsererror').length > 0) {
                    throw new Error('Invalid XML format');
                }

                const rulesElement = xmlDoc.querySelector('rules');
                if (!rulesElement) {
                    throw new Error('No <rules> element found');
                }

                function parseElement(element) {
                    if (element.tagName === 'group') {
                        const logic = element.getAttribute('logic') || 'AND';
                        const children = Array.from(element.children).map(parseElement);
                        return {
                            type: 'group',
                            logic: logic,
                            children: children
                        };
                    } else {
                        // It's a rule element
                        const ruleType = element.tagName;
                        const comparator = element.getAttribute('comparator') || 'equals';
                        const value = element.textContent || '';
                        
                        // Find the matching rule type from available types
                        const matchingType = availableTypes.find(t => t.value === ruleType);
                        if (!matchingType) {
                            throw new Error(`Unknown rule type: ${ruleType}`);
                        }
                        
                        // Find the matching comparator
                        const matchingComparator = matchingType.comparators.find(c => c.value === comparator);
                        if (!matchingComparator) {
                            throw new Error(`Unknown comparator: ${comparator} for rule type: ${ruleType}`);
                        }
                        
                        return {
                            type: 'rule',
                            ruleType: matchingType,
                            comparator: matchingComparator,
                            value: value
                        };
                    }
                }

                const rootElement = rulesElement.children[0];
                if (!rootElement) {
                    throw new Error('No root element found in rules');
                }

                // If the root element is already a group, return it directly
                if (rootElement.tagName === 'group') {
                    return parseElement(rootElement);
                }
                
                // If the root element is a rule, wrap it in a group
                if (rootElement.tagName !== 'group') {
                    return {
                        type: 'group',
                        logic: 'AND',
                        children: [parseElement(rootElement)]
                    };
                }

                return parseElement(rootElement);
            } catch (error) {
                console.error('Error parsing XML:', error);
                throw error;
            }
        }

        // Mock RuleBlock component
        const RuleBlock = ({ block, path, parent, onUpdate, onAddRule, onAddGroup, onRemoveBlock, availableTypes }) => {
            const [inputError, setInputError] = useState('');

            if (block.type === 'rule') {
                const inputField = block.ruleType.inputField;
                
                // Get input type and props based on input field configuration
                const getInputType = (inputField) => {
                    if (!inputField) return 'text';
                    switch (inputField.type) {
                        case 'string': return 'text';
                        case 'number': return 'number';
                        case 'date': return 'date';
                        case 'currency': return 'number';
                        case 'double': return 'number';
                        default: return 'text';
                    }
                };

                const getInputProps = (inputField) => {
                    const props = {
                        type: getInputType(inputField),
                        placeholder: inputField?.placeholder
                    };

                    if (['number', 'currency', 'double'].includes(inputField?.type)) {
                        if (inputField.min !== undefined) props.min = inputField.min;
                        if (inputField.max !== undefined) props.max = inputField.max;
                        if (inputField.step !== undefined) props.step = inputField.step;
                    }

                    return props;
                };

                const getCurrencySymbol = (inputField) => {
                    return inputField?.type === 'currency' ? inputField.currency || '$' : null;
                };

                const validateInput = (value, inputField) => {
                    if (!inputField?.validation) return '';

                    const { validation } = inputField;

                    // Check pattern validation
                    if (validation.pattern && value) {
                        const regex = new RegExp(validation.pattern);
                        if (!regex.test(value)) {
                            return 'Invalid format';
                        }
                    }

                    // Check length validation
                    if (validation.minLength && value.length < validation.minLength) {
                        return `Minimum length is ${validation.minLength} characters`;
                    }

                    if (validation.maxLength && value.length > validation.maxLength) {
                        return `Maximum length is ${validation.maxLength} characters`;
                    }

                    // Check custom validation
                    if (validation.custom) {
                        const customError = validation.custom(value);
                        if (customError) return customError;
                    }

                    return '';
                };

                const inputProps = getInputProps(inputField);
                const currencySymbol = getCurrencySymbol(inputField);

                const handleValueChange = (e) => {
                    let val = e.target.value;
                    let error = '';

                    // Apply formatting for currency and double types
                    if (inputField?.type === 'currency' && val) {
                        const num = parseFloat(val);
                        if (!isNaN(num)) {
                            val = num.toFixed(2);
                        }
                    } else if (inputField?.type === 'double' && val) {
                        const num = parseFloat(val);
                        if (!isNaN(num)) {
                            val = num.toFixed(2);
                        }
                    }

                    // Validate the input
                    if (inputField) {
                        error = validateInput(val, inputField);
                    }

                    setInputError(error);
                    onUpdate(path, (block) => {
                        if (block.type !== 'rule') return block;
                        return { ...block, value: val };
                    });
                };

                return (
                    <Paper elevation={2} sx={{ p: 2, m: 1, borderRadius: 2, display: 'flex', alignItems: 'center', gap: 2, flexWrap: 'wrap' }}>
                        <Select
                            value={block.ruleType.value}
                            onChange={e => onUpdate(path, (block) => {
                                if (block.type !== 'rule') return block;
                                const ruleType = availableTypes.find(t => t.value === e.target.value);
                                return {
                                    ...block,
                                    ruleType,
                                    comparator: ruleType.comparators[0],
                                    value: ''
                                };
                            })}
                            size="small"
                            sx={{ minWidth: 140 }}
                        >
                            {availableTypes.map(type => (
                                <MenuItem key={type.value} value={type.value}>{type.label}</MenuItem>
                            ))}
                        </Select>
                        <Select
                            value={block.comparator?.value || ''}
                            onChange={e => onUpdate(path, (block) => {
                                if (block.type !== 'rule') return block;
                                const ruleType = block.ruleType;
                                return {
                                    ...block,
                                    comparator: ruleType.comparators.find(c => c.value === e.target.value)
                                };
                            })}
                            size="small"
                            sx={{ minWidth: 140 }}
                        >
                            {block.ruleType?.comparators.map((comp) => (
                                <MenuItem key={comp.value} value={comp.value}>{comp.label}</MenuItem>
                            ))}
                        </Select>
                        <TextField
                            {...inputProps}
                            value={block.value}
                            onChange={handleValueChange}
                            size="small"
                            error={!!inputError}
                            helperText={inputError}
                            sx={{ minWidth: 120 }}
                            InputProps={currencySymbol ? { startAdornment: currencySymbol } : undefined}
                        />
                        {parent && (
                            <Button 
                                onClick={() => onRemoveBlock(path.slice(0, -1), path[path.length - 1])} 
                                color="error" 
                                variant="outlined" 
                                size="small" 
                                sx={{ ml: 1 }}
                            >
                                Remove Rule
                            </Button>
                        )}
                    </Paper>
                );
            }

            return (
                <Paper elevation={3} sx={{ p: 2, m: 2, borderRadius: 2 }}>
                    <Stack direction="row" alignItems="center" spacing={2} mb={2}>
                        <Select
                            value={block.logic}
                            onChange={e => onUpdate(path, (block) => {
                                if (block.type !== 'group') return block;
                                return { ...block, logic: e.target.value };
                            })}
                            size="small"
                        >
                            <MenuItem value="AND">ALL MATCH</MenuItem>
                            <MenuItem value="OR">ONE MATCHES</MenuItem>
                        </Select>
                        {parent && (
                            <Button 
                                onClick={() => onRemoveBlock(path.slice(0, -1), path[path.length - 1])} 
                                color="error" 
                                variant="outlined" 
                                size="small"
                            >
                                Remove Group
                            </Button>
                        )}
                    </Stack>
                    <Box ml={2}>
                        {block.children.map((child, i) => (
                            <RuleBlock 
                                key={i} 
                                block={child} 
                                path={[...path, i]} 
                                parent={block}
                                onUpdate={onUpdate}
                                onAddRule={onAddRule}
                                onAddGroup={onAddGroup}
                                onRemoveBlock={onRemoveBlock}
                                availableTypes={availableTypes}
                            />
                        ))}
                    </Box>
                    <Stack direction="row" spacing={2} mt={2}>
                        <Button 
                            onClick={() => onAddRule(path, block.children.length - 1)} 
                            variant="contained" 
                            size="small"
                        >
                            Add Rule
                        </Button>
                        <Button 
                            onClick={() => onAddGroup(path, block.children.length - 1)} 
                            variant="contained" 
                            size="small"
                        >
                            Add Group
                        </Button>
                    </Stack>
                </Paper>
            );
        };

        // Mock XmlRuleBuilder component
        const XmlRuleBuilder = ({ onXmlChange, initialRules, onValidationChange, config }) => {
            const [root, setRoot] = useState(initialRules || {
                type: 'group',
                logic: 'AND',
                children: [{
                    type: 'rule',
                    ruleType: (config?.xmlTypes || mockXmlTypes)[0],
                    comparator: (config?.xmlTypes || mockXmlTypes)[0].comparators[0],
                    value: ''
                }]
            });
            const [xml, setXml] = useState('');
            const [validation, setValidation] = useState({ isValid: false, errors: [] });

            const availableTypes = config?.xmlTypes || mockXmlTypes;

            useEffect(() => {
                if (initialRules) {
                    setRoot(initialRules);
                }
            }, [initialRules]);

            useEffect(() => {
                // Simple validation
                const errors = [];
                function validateBlock(block, path = 'root') {
                    if (block.type === 'rule') {
                        if (!block.value || block.value.trim() === '') {
                            errors.push(`${path}: Rule value is required`);
                        }
                    } else {
                        if (block.children.length === 0) {
                            errors.push(`${path}: Group must have at least one child`);
                        }
                        block.children.forEach((child, index) => {
                            validateBlock(child, `${path}.children[${index}]`);
                        });
                    }
                }
                
                validateBlock(root);
                const isValid = errors.length === 0;
                setValidation({ isValid, errors });
                
                if (onValidationChange) {
                    onValidationChange(isValid, errors);
                }
            }, [root, onValidationChange]);

            useEffect(() => {
                if (validation.isValid) {
                    // Generate XML
                    function generateXml(block) {
                        if (block.type === 'rule') {
                            return `<${block.ruleType.value} comparator="${block.comparator.value}">${block.value}</${block.ruleType.value}>`;
                        } else {
                            const children = block.children.map(generateXml).join('\n  ');
                            return `<group logic="${block.logic}">\n  ${children}\n</group>`;
                        }
                    }
                    
                    const generatedXml = `<rules>\n  ${generateXml(root)}\n</rules>`;
                    setXml(generatedXml);
                    if (onXmlChange) {
                        onXmlChange(generatedXml);
                    }
                }
            }, [root, validation.isValid, onXmlChange]);

            const handleUpdate = (path, updater) => {
                function updateBlockByPath(block, path, updater) {
                    if (path.length === 0) return updater(block);
                    if (block.type !== 'group') return block;
                    
                    const [head, ...rest] = path;
                    return {
                        ...block,
                        children: block.children.map((child, idx) =>
                            idx === head ? updateBlockByPath(child, rest, updater) : child
                        )
                    };
                }
                
                setRoot(updateBlockByPath(root, path, updater));
            };

            const handleAddRule = (path, index) => {
                setRoot(prevRoot => {
                    function updateBlockByPath(block, path, updater) {
                        if (path.length === 0) return updater(block);
                        if (block.type !== 'group') return block;
                        
                        const [head, ...rest] = path;
                        return {
                            ...block,
                            children: block.children.map((child, idx) =>
                                idx === head ? updateBlockByPath(child, rest, updater) : child
                            )
                        };
                    }
                    
                    return updateBlockByPath(prevRoot, path, (block) => {
                        if (block.type !== 'group') return block;
                        const children = [...block.children];
                        children.splice(index + 1, 0, {
                            type: 'rule',
                            ruleType: availableTypes[0],
                            comparator: availableTypes[0].comparators[0],
                            value: ''
                        });
                        return { ...block, children };
                    });
                });
            };

            const handleAddGroup = (path, index) => {
                setRoot(prevRoot => {
                    function updateBlockByPath(block, path, updater) {
                        if (path.length === 0) return updater(block);
                        if (block.type !== 'group') return block;
                        
                        const [head, ...rest] = path;
                        return {
                            ...block,
                            children: block.children.map((child, idx) =>
                                idx === head ? updateBlockByPath(child, rest, updater) : child
                            )
                        };
                    }
                    
                    return updateBlockByPath(prevRoot, path, (block) => {
                        if (block.type !== 'group') return block;
                        const children = [...block.children];
                        children.splice(index + 1, 0, {
                            type: 'group',
                            logic: 'AND',
                            children: [{
                                type: 'rule',
                                ruleType: availableTypes[0],
                                comparator: availableTypes[0].comparators[0],
                                value: ''
                            }]
                        });
                        return { ...block, children };
                    });
                });
            };

            const handleRemoveBlock = (path, index) => {
                setRoot(prevRoot => {
                    function updateBlockByPath(block, path, updater) {
                        if (path.length === 0) return updater(block);
                        if (block.type !== 'group') return block;
                        
                        const [head, ...rest] = path;
                        return {
                            ...block,
                            children: block.children.map((child, idx) =>
                                idx === head ? updateBlockByPath(child, rest, updater) : child
                            )
                        };
                    }
                    
                    return updateBlockByPath(prevRoot, path.slice(0, -1), (block) => {
                        if (block.type !== 'group' || block.children.length <= 1) return block;
                        const children = block.children.filter((_, i) => i !== index);
                        return { ...block, children };
                    });
                });
            };

            return (
                <Box sx={{ p: 2 }}>
                    <Typography variant="h5" gutterBottom>
                        XML Rule Builder
                    </Typography>
                    
                    {!validation.isValid && validation.errors.length > 0 && (
                        <Alert severity="warning" sx={{ mb: 2 }}>
                            <Typography variant="subtitle2" gutterBottom>
                                Validation Errors:
                            </Typography>
                            {validation.errors.map((error, index) => (
                                <Typography key={index} variant="body2">
                                    • {error}
                                </Typography>
                            ))}
                        </Alert>
                    )}

                    <RuleBlock 
                        block={root} 
                        path={[]} 
                        parent={null}
                        onUpdate={handleUpdate}
                        onAddRule={handleAddRule}
                        onAddGroup={handleAddGroup}
                        onRemoveBlock={handleRemoveBlock}
                        availableTypes={availableTypes}
                    />

                    {validation.isValid && xml && (
                        <Paper elevation={1} sx={{ p: 2, mt: 2, backgroundColor: '#f5f5f5' }}>
                            <Typography variant="h6" gutterBottom>
                                Generated XML:
                            </Typography>
                            <Box component="pre" sx={{ 
                                backgroundColor: '#fff', 
                                p: 2, 
                                borderRadius: 1, 
                                overflow: 'auto',
                                fontSize: '0.875rem',
                                border: '1px solid #ddd'
                            }}>
                                {xml}
                            </Box>
                        </Paper>
                    )}
                </Box>
            );
        };

        // Global variables for demo
        let currentTypes = [...mockXmlTypes];
        let currentOutput = '';

        // Helper function to escape HTML entities
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Demo functions
        window.loadDefaultTypes = function() {
            currentTypes = [...mockXmlTypes];
            ReactDOM.render(
                <XmlRuleBuilder 
                    onXmlChange={(xml) => {
                        currentOutput = xml;
                        const outputDiv = document.getElementById('default-output');
                        outputDiv.innerHTML = `
                            <div class="success">XML generated successfully!</div>
                            <div class="xml-output"></div>
                        `;
                        const xmlOutputDiv = outputDiv.querySelector('.xml-output');
                        xmlOutputDiv.textContent = xml;
                    }}
                    onValidationChange={(isValid, errors) => {
                        if (!isValid) {
                            document.getElementById('default-output').innerHTML = `
                                <div class="error">Validation errors: ${errors.join(', ')}</div>
                            `;
                        }
                    }}
                />,
                document.getElementById('default-builder')
            );
        };

        window.showDefaultConfig = function() {
            document.getElementById('default-output').innerHTML = `
                <div class="config-example">${JSON.stringify(mockXmlTypes, null, 2)}</div>
            `;
        };

        window.loadCustomTypes = function() {
            currentTypes = [...customTypes];
            ReactDOM.render(
                <XmlRuleBuilder 
                    config={{ xmlTypes: customTypes }}
                    onXmlChange={(xml) => {
                        currentOutput = xml;
                        const outputDiv = document.getElementById('custom-output');
                        outputDiv.innerHTML = `
                            <div class="success">XML generated successfully!</div>
                            <div class="xml-output"></div>
                        `;
                        const xmlOutputDiv = outputDiv.querySelector('.xml-output');
                        xmlOutputDiv.textContent = xml;
                    }}
                    onValidationChange={(isValid, errors) => {
                        if (!isValid) {
                            document.getElementById('custom-output').innerHTML = `
                                <div class="error">Validation errors: ${errors.join(', ')}</div>
                            `;
                        }
                    }}
                />,
                document.getElementById('custom-builder')
            );
        };

        window.resetToDefault = function() {
            currentTypes = [...mockXmlTypes];
            document.getElementById('custom-output').innerHTML = `
                <div class="success">Reset to default types successfully!</div>
            `;
        };

        window.loadFromFile = function() {
            currentTypes = [...fileTypes];
            ReactDOM.render(
                <XmlRuleBuilder 
                    config={{ xmlTypes: fileTypes }}
                    onXmlChange={(xml) => {
                        currentOutput = xml;
                        const outputDiv = document.getElementById('file-output');
                        outputDiv.innerHTML = `
                            <div class="success">XML generated successfully!</div>
                            <div class="xml-output"></div>
                        `;
                        const xmlOutputDiv = outputDiv.querySelector('.xml-output');
                        xmlOutputDiv.textContent = xml;
                    }}
                    onValidationChange={(isValid, errors) => {
                        if (!isValid) {
                            document.getElementById('file-output').innerHTML = `
                                <div class="error">Validation errors: ${errors.join(', ')}</div>
                            `;
                        }
                    }}
                />,
                document.getElementById('file-builder')
            );
        };

        window.showFileConfig = function() {
            document.getElementById('file-output').innerHTML = `
                <div class="config-example">${JSON.stringify({ ruleTypes: fileTypes }, null, 2)}</div>
            `;
        };

        window.loadSampleXml = function() {
            try {
                const initialRules = parseXmlToRules(sampleXml, mockXmlTypes);
                console.log('Parsed initial rules:', initialRules);
                
                ReactDOM.render(
                    <XmlRuleBuilder 
                        initialRules={initialRules}
                        onXmlChange={(xml) => {
                            currentOutput = xml;
                            const outputDiv = document.getElementById('import-output');
                            outputDiv.innerHTML = `
                                <div class="success">XML imported and updated successfully!</div>
                                <div class="xml-output"></div>
                            `;
                            const xmlOutputDiv = outputDiv.querySelector('.xml-output');
                            xmlOutputDiv.textContent = xml;
                        }}
                        onValidationChange={(isValid, errors) => {
                            if (!isValid) {
                                document.getElementById('import-output').innerHTML = `
                                    <div class="error">Validation errors: ${errors.join(', ')}</div>
                                `;
                            }
                        }}
                    />,
                    document.getElementById('import-builder')
                );
                
                document.getElementById('import-output').innerHTML = `
                    <div class="success">Sample XML loaded successfully! The rules builder should now show the imported rules above.</div>
                    <div class="config-example">${sampleXml}</div>
                `;
            } catch (error) {
                console.error('Error in loadSampleXml:', error);
                document.getElementById('import-output').innerHTML = `
                    <div class="error">Error loading sample XML: ${error.message}</div>
                `;
            }
        };

        window.loadCustomXml = function() {
            const customXml = prompt('Enter your XML:', sampleXml);
            if (!customXml) return;
            
            try {
                const initialRules = parseXmlToRules(customXml, mockXmlTypes);
                console.log('Parsed custom initial rules:', initialRules);
                
                ReactDOM.render(
                    <XmlRuleBuilder 
                        initialRules={initialRules}
                        onXmlChange={(xml) => {
                            currentOutput = xml;
                            const outputDiv = document.getElementById('import-output');
                            outputDiv.innerHTML = `
                                <div class="success">Custom XML imported and updated successfully!</div>
                                <div class="xml-output"></div>
                            `;
                            const xmlOutputDiv = outputDiv.querySelector('.xml-output');
                            xmlOutputDiv.textContent = xml;
                        }}
                        onValidationChange={(isValid, errors) => {
                            if (!isValid) {
                                document.getElementById('import-output').innerHTML = `
                                    <div class="error">Validation errors: ${errors.join(', ')}</div>
                                `;
                            }
                        }}
                    />,
                    document.getElementById('import-builder')
                );
                
                document.getElementById('import-output').innerHTML = `
                    <div class="success">Custom XML loaded successfully! The rules builder should now show the imported rules above.</div>
                    <div class="config-example">${customXml}</div>
                `;
            } catch (error) {
                console.error('Error in loadCustomXml:', error);
                document.getElementById('import-output').innerHTML = `
                    <div class="error">Error loading custom XML: ${error.message}</div>
                `;
            }
        };

        window.clearImport = function() {
            document.getElementById('import-builder').innerHTML = '';
            document.getElementById('import-output').innerHTML = `
                <div class="success">Import cleared successfully!</div>
            `;
        };

        window.switchTab = function(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
        };

        // Initialize default demo
        window.loadDefaultTypes();
    </script>
</body>
</html> 